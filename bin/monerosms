#!/usr/bin/env bash

# @describe MoneroSMS API client for sending SMS messages
# @arg command "Command to run (send, balance, price, generate)" [string]
# @arg to "Phone number to send message to (required for send)" [string]
# @arg message "Message content to send (required for send)" [string]
# @option -t --token "MoneroSMS API token (can also use MONERO_SMS_TOKEN env var)" [string]
# @option -f --auth-file "Auth file path" [string] @default "monerosms-auth"
# @option -u --url "Base URL for API" [string] @default "https://api.monerosms.com/"
# @option --tor-port "Tor SOCKS proxy port (enables Tor mode)" [int]
# @flag   --transparent-tor "Use Tor without SOCKS proxy"
# @flag   -j --json "Output raw JSON instead of formatted results"
# @flag   -q --quiet "Suppress colored output"
# @meta require-tools curl,jq
# @meta version 1.0.3

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    _argc_require_tools "${_argc_tools[@]}"
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
monerosms 1.0.3
MoneroSMS API client for sending SMS messages

USAGE: monerosms [OPTIONS] [COMMAND] [TO] [MESSAGE]

ARGS:
  [COMMAND]  "Command to run (send, balance, price, generate)" [string]
  [TO]       "Phone number to send message to (required for send)" [string]
  [MESSAGE]  "Message content to send (required for send)" [string]

OPTIONS:
  -t, --token <TOKEN>          "MoneroSMS API token (can also use MONERO_SMS_TOKEN env var)" [string]
  -f, --auth-file <AUTH-FILE>  "Auth file path" [string] @default "monerosms-auth"
  -u, --url <URL>              "Base URL for API" [string] @default "https://api.monerosms.com/"
      --tor-port <TOR-PORT>    "Tor SOCKS proxy port (enables Tor mode)" [int]
      --transparent-tor        "Use Tor without SOCKS proxy"
  -j, --json                   "Output raw JSON instead of formatted results"
  -q, --quiet                  "Suppress colored output"
  -h, --help                   Print help
  -V, --version                Print version
EOF
    exit
}

_argc_version() {
    echo monerosms 1.0.3
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --token | -t)
            _argc_take_args "--token <TOKEN>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_token:-}" ]]; then
                argc_token="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--token\` cannot be used multiple times"
            fi
            ;;
        --auth-file | -f)
            _argc_take_args "--auth-file <AUTH-FILE>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_auth_file:-}" ]]; then
                argc_auth_file="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--auth-file\` cannot be used multiple times"
            fi
            ;;
        --url | -u)
            _argc_take_args "--url <URL>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_url:-}" ]]; then
                argc_url="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--url\` cannot be used multiple times"
            fi
            ;;
        --tor-port)
            _argc_take_args "--tor-port <TOR-PORT>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_tor_port:-}" ]]; then
                argc_tor_port="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--tor-port\` cannot be used multiple times"
            fi
            ;;
        --transparent-tor)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--transparent-tor\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_transparent_tor:-}" ]]; then
                _argc_die "error: the argument \`--transparent-tor\` cannot be used multiple times"
            else
                argc_transparent_tor=1
            fi
            ;;
        --json | -j)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--json\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_json:-}" ]]; then
                _argc_die "error: the argument \`--json\` cannot be used multiple times"
            else
                argc_json=1
            fi
            ;;
        --quiet | -q)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--quiet\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_quiet:-}" ]]; then
                _argc_die "error: the argument \`--quiet\` cannot be used multiple times"
            else
                argc_quiet=1
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(curl jq)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage
        fi
        _argc_match_positionals 0 0 0
        local values_index values_size
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[0]:-}"
        if [[ -n "$values_index" ]]; then
            argc_command="${argc__positionals[values_index]}"
        fi
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[1]:-}"
        if [[ -n "$values_index" ]]; then
            argc_to="${argc__positionals[values_index]}"
        fi
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[2]:-}"
        if [[ -n "$values_index" ]]; then
            argc_message="${argc__positionals[values_index]}"
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_match_positionals() {
    _argc_match_positionals_values=()
    _argc_match_positionals_len=0
    local params=("$@")
    local args_len="${#argc__positionals[@]}"
    if [[ $args_len -eq 0 ]]; then
        return
    fi
    local params_len=$# arg_index=0 param_index=0
    while [[ $param_index -lt $params_len && $arg_index -lt $args_len ]]; do
        local takes=0
        if [[ "${params[param_index]}" -eq 1 ]]; then
            if [[ $param_index -eq 0 ]] &&
                [[ ${_argc_dash:-} -gt 0 ]] &&
                [[ $params_len -eq 2 ]] &&
                [[ "${params[$((param_index + 1))]}" -eq 1 ]] \
                ; then
                takes=${_argc_dash:-}
            else
                local arg_diff=$((args_len - arg_index)) param_diff=$((params_len - param_index))
                if [[ $arg_diff -gt $param_diff ]]; then
                    takes=$((arg_diff - param_diff + 1))
                else
                    takes=1
                fi
            fi
        else
            takes=1
        fi
        _argc_match_positionals_values+=("$arg_index:$takes")
        arg_index=$((arg_index + takes))
        param_index=$((param_index + 1))
    done
    if [[ $arg_index -lt $args_len ]]; then
        _argc_match_positionals_values+=("$arg_index:$((args_len - arg_index))")
    fi
    _argc_match_positionals_len=${#_argc_match_positionals_values[@]}
    if [[ $params_len -gt 0 ]] && [[ $_argc_match_positionals_len -gt $params_len ]]; then
        local index="${_argc_match_positionals_values[params_len]%%:*}"
        _argc_die "error: unexpected argument \`${argc__positionals[index]}\` found"
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_require_tools() {
    local tool missing_tools=()
    for tool in "$@"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done
    if [[ "${#missing_tools[@]}" -gt 0 ]]; then
        echo "error: missing tools: ${missing_tools[*]}" >&2
        exit 1
    fi
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }

VERSION="1.0.3"

# Setup colors
setup_colors() {
  if [ "$argc_quiet" = 1 ] || [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
    bold="" reset="" blue="" green="" yellow="" cyan="" magenta="" red=""
  else
    bold=$(tput bold) reset=$(tput sgr0) blue=$(tput setaf 4) green=$(tput setaf 2)
    yellow=$(tput setaf 3) cyan=$(tput setaf 6) magenta=$(tput setaf 5) red=$(tput setaf 1)
  fi
}
setup_colors

# Configure base URL and proxy settings
setup_connection() {
  if [ -n "$argc_tor_port" ] || [ -n "$MONERO_SMS_TOR" ]; then
    tor_port="${argc_tor_port:-$MONERO_SMS_TOR}"
    if [ -n "$tor_port" ]; then
      base_url="http://api.xmr4smsoncunkfgfjr6xmxl57afsmuu6rg2bwuysbgg4wdtoawamwxad.onion/"
      if [ "$argc_transparent_tor" != 1 ] && [ -z "$MONERO_SMS_TRANSPARENT_TOR" ]; then
        proxy_args="--socks4a 127.0.0.1:${tor_port}"
      fi
    fi
  else
    base_url="${argc_url}"
  fi
}

# Get API token from multiple sources
get_token() {
  if [ -n "$argc_token" ]; then
    echo "$argc_token"
  elif [ -n "$MONERO_SMS_TOKEN" ]; then
    echo "$MONERO_SMS_TOKEN"
  elif [ -f "$argc_auth_file" ]; then
    cat "$argc_auth_file"
  else
    return 1
  fi
}

# Generate auth file
generate_auth() {
  printf "${bold}MoneroSMS Auth File Generator${reset}\n\n"
  printf "Enter your MoneroSMS API token: "
  read -s token
  printf "\n"

  if [ -z "$token" ]; then
    printf "${red}Error:${reset} No token provided\n" >&2
    exit 1
  fi

  echo "$token" > "$argc_auth_file"
  printf "${green}Success:${reset} Token saved to ${cyan}%s${reset}\n" "$argc_auth_file"
  printf "You can now use MoneroSMS commands without specifying the token\n"
}

# Make API request
make_request() {
  local endpoint="$1"
  local method="${2:-GET}"
  local data="$3"
  local token="$4"

  local url="${base_url}${endpoint}"
  local curl_args="-s"

  # Add proxy if configured
  [ -n "$proxy_args" ] && curl_args="$curl_args $proxy_args"

  # Add auth header
  [ -n "$token" ] && curl_args="$curl_args -H 'Authorization: Bearer $token'"

  # Add method and data
  if [ "$method" = "POST" ]; then
    curl_args="$curl_args -X POST"
    [ -n "$data" ] && curl_args="$curl_args -d '$data'"
  fi

  local response=$(eval "curl $curl_args '$url'")

  # Check for API errors
  if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
    error_msg=$(echo "$response" | jq -r '.error')
    printf "${red}Error:${reset} API returned: ${red}%s${reset}\n" "$error_msg" >&2
    exit 1
  fi

  echo "$response"
}

# Helper functions
print_kv() {
  printf "${bold}%s:${reset} %s\n" "$1" "$2"
}

print_section() {
  printf "\n${bold}%s:${reset}\n" "$1"
}

show_help() {
  echo "${bold}MoneroSMS API Client v${VERSION}${reset}"
  echo ""
  echo "${bold}Commands:${reset}"
  echo "  ${cyan}send${reset}          Send SMS message"
  echo "  ${cyan}balance${reset}       Check account balance"
  echo "  ${cyan}price${reset}         Get SMS pricing"
  echo "  ${cyan}generate${reset}      Generate auth file"
  echo ""
  echo "${bold}Examples:${reset}"
  echo "  ${green}$(basename "$0") generate${reset}"
  echo "  ${green}$(basename "$0") send +1234567890 \"Hello world\"${reset}"
  echo "  ${green}$(basename "$0") balance${reset}"
  echo "  ${green}$(basename "$0") price${reset}"
  echo ""
  echo "${bold}Authentication:${reset}"
  echo "  The API token can be provided via:"
  echo "  1. ${yellow}--token${reset} flag"
  echo "  2. ${yellow}MONERO_SMS_TOKEN${reset} environment variable"
  echo "  3. ${yellow}monerosms-auth${reset} file (use 'generate' command to create)"
  echo ""
  echo "${bold}Tor Support:${reset}"
  echo "  ${yellow}--tor-port${reset}        Enable Tor via SOCKS proxy on specified port"
  echo "  ${yellow}--transparent-tor${reset}  Use Tor without SOCKS proxy"
  echo "  ${yellow}MONERO_SMS_TOR${reset}     Environment variable for Tor port"
}

# Format handlers
format_send_result() {
  local response="$1"
  local success=$(echo "$response" | jq -r '.success // false')
  local message_id=$(echo "$response" | jq -r '.message_id // "N/A"')
  local cost=$(echo "$response" | jq -r '.cost // "N/A"')
  local balance=$(echo "$response" | jq -r '.remaining_balance // "N/A"')

  if [ "$success" = "true" ]; then
    printf "${green}✓ Message sent successfully${reset}\n"
    [ "$message_id" != "N/A" ] && print_kv "Message ID" "${blue}$message_id${reset}"
    [ "$cost" != "N/A" ] && print_kv "Cost" "${yellow}$cost XMR${reset}"
    [ "$balance" != "N/A" ] && print_kv "Remaining Balance" "${cyan}$balance XMR${reset}"
  else
    printf "${red}✗ Failed to send message${reset}\n"
  fi
}

format_balance() {
  local response="$1"
  local balance=$(echo "$response" | jq -r '.balance // "N/A"')
  local pending=$(echo "$response" | jq -r '.pending_balance // "N/A"')

  print_kv "Balance" "${green}$balance XMR${reset}"
  [ "$pending" != "N/A" ] && [ "$pending" != "0" ] && print_kv "Pending" "${yellow}$pending XMR${reset}"
}

format_price() {
  local response="$1"

  printf "${bold}SMS Pricing:${reset}\n"
  echo "$response" | jq -r 'to_entries[] | "\(.key)|\(.value)"' | sort |
    while IFS="|" read -r country price; do
      printf "  ${cyan}%s:${reset} ${yellow}%s XMR${reset}\n" "$country" "$price"
    done
}

# Main execution
setup_connection

if [ -z "$argc_command" ]; then
  show_help
  exit 0
fi

case "$argc_command" in
generate)
  generate_auth
  ;;

send)
  if [ -z "$argc_to" ] || [ -z "$argc_message" ]; then
    printf "${red}Error:${reset} Both phone number and message are required for send command\n" >&2
    printf "Usage: %s send <phone_number> <message>\n" "$(basename "$0")" >&2
    exit 1
  fi

  token=$(get_token)
  if [ -z "$token" ]; then
    printf "${red}Error:${reset} No MoneroSMS API token found.\n" >&2
    printf "Either:\n" >&2
    printf "  1. Pass it with --token\n" >&2
    printf "  2. Set MONERO_SMS_TOKEN environment variable\n" >&2
    printf "  3. Generate auth file with: %s generate\n" "$(basename "$0")" >&2
    exit 1
  fi

  # URL encode the message
  encoded_message=$(printf '%s' "$argc_message" | jq -sRr @uri)
  encoded_to=$(printf '%s' "$argc_to" | jq -sRr @uri)

  data="to=${encoded_to}&message=${encoded_message}"
  response=$(make_request "send" "POST" "$data" "$token")

  [ "$argc_json" = 1 ] && echo "$response" | jq || format_send_result "$response"
  ;;

balance)
  token=$(get_token)
  if [ -z "$token" ]; then
    printf "${red}Error:${reset} No MoneroSMS API token found.\n" >&2
    printf "Generate auth file with: %s generate\n" "$(basename "$0")" >&2
    exit 1
  fi

  response=$(make_request "balance" "GET" "" "$token")
  [ "$argc_json" = 1 ] && echo "$response" | jq || format_balance "$response"
  ;;

price)
  response=$(make_request "price" "GET" "" "")
  [ "$argc_json" = 1 ] && echo "$response" | jq || format_price "$response"
  ;;

*)
  printf "${red}Error:${reset} Unknown command: %s\n" "$argc_command" >&2
  show_help
  exit 1
  ;;
esac
